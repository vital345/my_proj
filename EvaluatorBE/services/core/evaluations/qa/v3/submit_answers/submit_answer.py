import time
from fastapi import BackgroundTasks
from sqlalchemy.orm import Session
from schemas.qa import InputQuestion, QARequest, Question
from typing import Dict, List
from services.ai.agents.domain_specific_qa.autogenerated_questions_qa_agent import (
    Question,
)
from sqlalchemy.orm import Session
from db.models.evaluation_step import EvaluationStep
from db.models.user_evaluation import UserEvaluation
from db.models.chat_session import ChatSession
from db.models.chat_history import ChatHistory
from services.ai.agents.project_specific_qa_agent_v3.output_formatter import FinalReport
from services.core.evaluations.qa.v2.project_specific_qa import project_specific_qa
from db.chat_history import get_chat_history
from db.models.evaluation import Evaluation
from fastapi import BackgroundTasks, UploadFile, Response
from services.ai.speech_processing.speech_to_text import convert_speech_to_text
import json
from services.ai.agents.eleven_labs.text_to_audio import convert_text_to_audio
from fastapi.responses import JSONResponse
import base64

from services.core.evaluations.qa.v3.get_queue import get_score_for_individual_answer
from services.core.evaluations.qa.v3.submit_answers.predefined_question_agent import (
    domain_specific_agent,
)
from services.core.evaluations.qa.v3.submit_answers.project_specific_question_agent import (
    project_specific_agent,
)


def submit_answer_domain_specific(
    chat_id: int,
    answer: QARequest | UploadFile,
    db: Session,
    response_queues: Dict[int, List[Dict]],
    background_tasks: BackgroundTasks,
    already_asked_questions,
):
    print(f"submit_answer_domain_specific called with chat_id: {chat_id}")

    user_evaluation_id: int = (
        db.query(ChatSession).where(ChatSession.id == chat_id).first().userevaluation_id
    )
    print(f"user_evaluation_id: {user_evaluation_id}")

    userEvaluation: UserEvaluation = (
        db.query(UserEvaluation).where(UserEvaluation.id == user_evaluation_id).first()
    )
    print(f"userEvaluation: {userEvaluation}")

    chatSession: ChatSession = (
        db.query(ChatSession).where(ChatSession.id == chat_id).first()
    )
    print(f"chatSession: {chatSession}")

    evaluation = (
        db.query(Evaluation)
        .where(Evaluation.id == userEvaluation.evaluation_id)
        .first()
    )
    print(f"evaluation: {evaluation}")

    if (
        db.query(EvaluationStep)
        .where(EvaluationStep.step_name == "domain_specific_qa")
        .where(EvaluationStep.userevaluation_id == userEvaluation.id)
        .first()
        != None
    ):
        print("Evaluation already completed")
        return {
            "question": None,
            "is_complete": True,
            "errors": ["evaluation already completed"],
            "viva_type": "domain_specific_qa",
        }

    if not isinstance(answer, QARequest):
        print("Converting speech to text")
        t = time.time()
        query = convert_speech_to_text(answer)
        print(time.time() - t)
    else:
        query = answer.answer
    print(f"query: {query}")

    if evaluation.questions == None:
        print("No questions found")
        return {
            "question": None,
            "is_complete": True,
            "errors": ["No questions found"],
            "viva_type": "domain_specific_qa",
        }
    else:
        chat_history = domain_specific_agent(
            session_id=chat_id,
            list_of_questions=evaluation.questions,
            domain_name=evaluation.track_name,
            query=query,
            response_queues=response_queues,
            background_tasks=background_tasks,
            already_asked_questions=already_asked_questions,
        )
        print(f"chat_history: {chat_history.messages}")
        return {
            "chat_history": chat_history.messages,
            "is_complete": False,
            "errors": [],
            "viva_type": "domain_specific_qa",
        }


async def submit_answer_project_specific(
    chat_id: int,
    answer: QARequest | UploadFile,
    db: Session,
    response_queues: Dict[int, List[Dict]],
    background_tasks: BackgroundTasks,
    already_asked_questions,
):
    print(f"submit_answer_project_specific called with chat_id: {chat_id}")

    user_evaluation_id: int = (
        db.query(ChatSession).where(ChatSession.id == chat_id).first().userevaluation_id
    )
    print(f"user_evaluation_id: {user_evaluation_id}")

    userEvaluation: UserEvaluation = (
        db.query(UserEvaluation).where(UserEvaluation.id == user_evaluation_id).first()
    )
    print(f"userEvaluation: {userEvaluation}")

    chatSession: ChatSession = (
        db.query(ChatSession).where(ChatSession.id == chat_id).first()
    )
    print(f"chatSession: {chatSession}")

    evaluation = (
        db.query(Evaluation)
        .where(Evaluation.id == userEvaluation.evaluation_id)
        .first()
    )
    print(f"evaluation: {evaluation}")

    if (
        db.query(EvaluationStep)
        .where(EvaluationStep.step_name == "project_specific_qa")
        .where(EvaluationStep.userevaluation_id == userEvaluation.id)
        .first()
        != None
    ):
        print("Evaluation already completed")
        chat_history = get_chat_history(chat_id)
        processed_chat_history = []
        for message in chat_history.messages:
            if message.type != "ai":
                processed_chat_history.append(message.content)
            else:
                processed_chat_history.append(message.content)
        return {
            "question": None,
            "is_complete": True,
            "errors": ["evaluation already completed"],
            "viva_type": "project_specific_qa",
            "chat_history": processed_chat_history,
        }

    if not isinstance(answer, QARequest):
        print("Converting speech to text")
        t = time.time()
        query = convert_speech_to_text(answer)
        print(time.time() - t)
    else:
        query = answer.answer
    print(f"query: {query}")

    milestone_report = (
        db.query(EvaluationStep)
        .where(EvaluationStep.step_name == "milestone_wise_report")
        .where(EvaluationStep.userevaluation_id == userEvaluation.id)
        .first()
    )
    print(f"milestone_report: {milestone_report}")

    questions = []

    for milestone in milestone_report.step_report["milestone_reports"]:
        questions = questions + milestone.get("questions", [])
    print(f"questions: {questions}")

    chat_history = get_chat_history(chat_id)
    print(f"chat_history before agent: {chat_history}")

    result = project_specific_agent(
        chat_id,
        questions,
        query,
        response_queues,
        background_tasks,
        chat_history,
        already_asked_questions,
    )
    print(f"result from agent: {result}")

    if isinstance(result, FinalReport):
        try:
            del response_queues[chat_id]
            del already_asked_questions[chat_id]
        except:
            pass
        # chat_history_dump = [message.model_dump() for message in chat_history.messages]
        chat_history_dump = [message.model_dump() for message in chat_history.messages]
        output = await get_score_for_individual_answer(chat_history_dump)
                    

        print("Inside submit_answer_project_specific")
        print("New Object project: ", output)
        print("questions: ", chat_history_dump)
        db.add(
            EvaluationStep(
                userevaluation_id=userEvaluation.id,
                step_name="project_specific_qa",
                step_report={
                    "score": output.overall_score,       # object_from_queue.score
                    "explanation": output.overall_feedback, # object_from_queue.explanation
                    "questions": chat_history_dump,
                },
            )
        )
        db.commit()

        db.query(ChatHistory).where(ChatHistory.session_id == chatSession.id).delete()

        db.commit()
        processed_chat_history = []
        for message in chat_history.messages:
            if message.type != "ai":
                processed_chat_history.append(message.content)
            else:
                processed_chat_history.append(message.content)
        print(f"processed_chat_history 1: {processed_chat_history}")
        return {
            "chat_history": processed_chat_history,
            "is_complete": True,
            "errors": [],
            "viva_type": "project_specific_qa",
        }
    else:
        processed_chat_history = []
        print("Chat History messages, Recent error")
        print(chat_history.messages)
        for message in chat_history.messages:
            if message.type != "ai":
                processed_chat_history.append(message)
            else:
                processed_chat_history.append(message)
        print(f"processed_chat_history 2: {processed_chat_history}")
        return {
            "chat_history": processed_chat_history,
            "is_complete": False,
            "errors": [],
            "viva_type": "project_specific_qa",
        }
