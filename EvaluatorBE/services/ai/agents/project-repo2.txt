This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-28T00:01:27.721Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
alembic.ini
alembic/env.py
alembic/README
alembic/script.py.mako
alembic/versions/2cf4d12a1b84_update_product_table.py
alembic/versions/46cb6335c67e_.py
alembic/versions/48cb21745a0b_update_user_id_foreign_key_to_product_.py
alembic/versions/58caf452d14b_.py
alembic/versions/635753dec3c7_adde_user_id_foreign_key_to_product_.py
alembic/versions/7f3ae4d20987_.py
alembic/versions/de38975c7a21_.py
alembic/versions/f99d3f34ee1f_first_commit.py
api/route_category.py
api/route_login.py
api/route_product.py
api/route_user.py
core/config.py
core/hashing.py
core/jwt.py
db/base_class.py
db/base.py
db/models/category.py
db/models/product.py
db/models/user.py
db/repository/category.py
db/repository/login.py
db/repository/product.py
db/repository/user.py
db/session.py
main.py
Pipfile
readme.md
schemas/category.py
schemas/product.py
schemas/token.py
schemas/user.py

================================================================
Repository Files
================================================================

================
File: .gitignore
================
.env
__pycache__/

================
File: alembic.ini
================
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

================
File: alembic/env.py
================
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

from db.base import Base
from core.config import settings
# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config
config.set_main_option("sqlalchemy.url",settings.DB_URL)

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

================
File: alembic/README
================
Generic single-database configuration.

================
File: alembic/script.py.mako
================
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}

================
File: alembic/versions/2cf4d12a1b84_update_product_table.py
================
"""update Product table

Revision ID: 2cf4d12a1b84
Revises: f99d3f34ee1f
Create Date: 2024-11-04 16:46:45.707963

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '2cf4d12a1b84'
down_revision: Union[str, None] = 'f99d3f34ee1f'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('product', 'name',
               existing_type=sa.INTEGER(),
               type_=sa.String(),
               existing_nullable=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('product', 'name',
               existing_type=sa.String(),
               type_=sa.INTEGER(),
               existing_nullable=False)
    # ### end Alembic commands ###

================
File: alembic/versions/46cb6335c67e_.py
================
"""empty message

Revision ID: 46cb6335c67e
Revises: 58caf452d14b
Create Date: 2024-11-04 23:04:34.657213

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '46cb6335c67e'
down_revision: Union[str, None] = '58caf452d14b'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint('product_category_id_fkey', 'product', type_='foreignkey')
    op.create_foreign_key(None, 'product', 'category', ['category_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'product', type_='foreignkey')
    op.create_foreign_key('product_category_id_fkey', 'product', 'user', ['category_id'], ['id'])
    # ### end Alembic commands ###

================
File: alembic/versions/48cb21745a0b_update_user_id_foreign_key_to_product_.py
================
"""update user_id foreign key to Product table

Revision ID: 48cb21745a0b
Revises: 635753dec3c7
Create Date: 2024-11-04 17:41:24.247796

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '48cb21745a0b'
down_revision: Union[str, None] = '635753dec3c7'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('product', sa.Column('owner_id', sa.Integer(), nullable=True))
    op.drop_constraint('product_user_id_fkey', 'product', type_='foreignkey')
    op.create_foreign_key(None, 'product', 'user', ['owner_id'], ['id'])
    op.drop_column('product', 'user_id')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('product', sa.Column('user_id', sa.INTEGER(), autoincrement=False, nullable=True))
    op.drop_constraint(None, 'product', type_='foreignkey')
    op.create_foreign_key('product_user_id_fkey', 'product', 'user', ['user_id'], ['id'])
    op.drop_column('product', 'owner_id')
    # ### end Alembic commands ###

================
File: alembic/versions/58caf452d14b_.py
================
"""empty message

Revision ID: 58caf452d14b
Revises: 48cb21745a0b
Create Date: 2024-11-04 23:00:02.358895

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '58caf452d14b'
down_revision: Union[str, None] = '48cb21745a0b'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('category', 'name',
               existing_type=sa.INTEGER(),
               type_=sa.String(),
               existing_nullable=False)
    op.add_column('product', sa.Column('category_id', sa.Integer(), nullable=True))
    op.drop_constraint('product_owner_id_fkey', 'product', type_='foreignkey')
    op.create_foreign_key(None, 'product', 'user', ['category_id'], ['id'])
    op.drop_column('product', 'owner_id')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('product', sa.Column('owner_id', sa.INTEGER(), autoincrement=False, nullable=True))
    op.drop_constraint(None, 'product', type_='foreignkey')
    op.create_foreign_key('product_owner_id_fkey', 'product', 'user', ['owner_id'], ['id'])
    op.drop_column('product', 'category_id')
    op.alter_column('category', 'name',
               existing_type=sa.String(),
               type_=sa.INTEGER(),
               existing_nullable=False)
    # ### end Alembic commands ###

================
File: alembic/versions/635753dec3c7_adde_user_id_foreign_key_to_product_.py
================
"""adde user_id foreign key to Product table

Revision ID: 635753dec3c7
Revises: 2cf4d12a1b84
Create Date: 2024-11-04 17:27:08.605177

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '635753dec3c7'
down_revision: Union[str, None] = '2cf4d12a1b84'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('product', sa.Column('user_id', sa.Integer(), nullable=True))
    op.create_foreign_key(None, 'product', 'user', ['user_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'product', type_='foreignkey')
    op.drop_column('product', 'user_id')
    # ### end Alembic commands ###

================
File: alembic/versions/7f3ae4d20987_.py
================
"""empty message

Revision ID: 7f3ae4d20987
Revises: de38975c7a21
Create Date: 2024-11-05 07:11:47.804312

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '7f3ae4d20987'
down_revision: Union[str, None] = 'de38975c7a21'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_unique_constraint(None, 'user', ['username'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'user', type_='unique')
    # ### end Alembic commands ###

================
File: alembic/versions/de38975c7a21_.py
================
"""empty message

Revision ID: de38975c7a21
Revises: 46cb6335c67e
Create Date: 2024-11-04 23:06:20.367056

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'de38975c7a21'
down_revision: Union[str, None] = '46cb6335c67e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

================
File: alembic/versions/f99d3f34ee1f_first_commit.py
================
"""first commit

Revision ID: f99d3f34ee1f
Revises: 
Create Date: 2024-11-04 16:10:11.290517

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'f99d3f34ee1f'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('category',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.Integer(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('product',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.Integer(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', sa.Integer(), nullable=False),
    sa.Column('stock_quantity', sa.Integer(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(), nullable=False),
    sa.Column('password', sa.String(), nullable=False),
    sa.Column('role', sa.String(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('user')
    op.drop_table('product')
    op.drop_table('category')
    # ### end Alembic commands ###

================
File: api/route_category.py
================
from fastapi import APIRouter, Depends, HTTPException, status
from schemas.category import CreateCategory, UpdateCategory
from sqlalchemy.orm import Session
from db.session import get_db
from db.repository.category import *
from db.models.category import Category
from api.route_login import get_current_user


router = APIRouter()


@router.get("/{id}")
def get_category(id: int, db: Session = Depends(get_db)):
    category = get_category_by_id(id, db)
    if not (category):
        raise HTTPException(
            detail=f"category with id = {id} not found", status_code=status.HTTP_404_NOT_FOUND)
    return category


@router.post("/")
def add_category(
    category: CreateCategory,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
    # This function will add authentication to the route
    # it will return unauthorized in case of absence or invalid jwt token
):
    category = create_category(category, db, user)
    return category


@router.get("/")
def get_all(db: Session = Depends(get_db)):
    return get_all_categories(db)


@router.put("/{id}")
def update_a_category(
    id: int,
    category: UpdateCategory,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):

    result = update_categories(id, category, db, user)

    if isinstance(result, str):
        if (result == "not_found"):
            raise HTTPException(
                detail=f"category with id = {id} not found", status_code=status.HTTP_404_NOT_FOUND)
        elif (result == "unauthorized"):
            raise HTTPException(detail="Unauthorized",
                                status_code=status.HTTP_401_UNAUTHORIZED)

    return result


@router.delete("/{id}")
def delete_a_category(
    id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    result = delete_category(id, db, user)

    if (result == "not_found"):
        raise HTTPException(
            detail=f"category with id = {id} not found", status_code=status.HTTP_404_NOT_FOUND)
    elif (result == "unauthorized"):
        raise HTTPException(detail="Unauthorized",
                            status_code=status.HTTP_401_UNAUTHORIZED)

    return {"message": "category deleted successfully"}

================
File: api/route_login.py
================
from core.config import settings
from core.hashing import Hasher
from core.jwt import create_access_token
from db.repository.login import get_user
from db.session import get_db
from fastapi import APIRouter
from fastapi import Depends
from fastapi import HTTPException
from fastapi import status
from fastapi.security import OAuth2PasswordBearer
from fastapi.security import OAuth2PasswordRequestForm
from jose import jwt
from jose import JWTError
from schemas.token import Token
from sqlalchemy.orm import Session


router = APIRouter()


def authenticate_user(email: str, password: str, db: Session):
    user = get_user(email,db)
    # print(user)
    if not user:
        return False
    if not Hasher.verify_password(password, user.password):
        return False
    return user


@router.post("/token", response_model=Token)
def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)
):
    user = authenticate_user(form_data.username, form_data.password, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
        )
    access_token = create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/token")
# tokenUrl="/token" is only useful in swagger it does not implement any functionality
 


def get_current_user(
    token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
    )

    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = get_user(username,db)
    if user is None:
        raise credentials_exception
    return user

================
File: api/route_product.py
================
from fastapi import APIRouter, Depends, HTTPException, status
from schemas.product import CreateProduct, UpdateProduct
from sqlalchemy.orm import Session
from db.session import get_db
from db.repository.product import create_product, get_product_by_id, get_all_products, update_product, delete_product
from db.models.user import User
from api.route_login import get_current_user


router = APIRouter()


@router.get("/{id}")
def get_product(id: int, db: Session = Depends(get_db)):
    product = get_product_by_id(id, db)
    if not (product):
        raise HTTPException(
            detail=f"product with id = {id} not found", status_code=status.HTTP_404_NOT_FOUND)
    return product
    # return {"message":id}


@router.post("/")
def add_product(
    product: CreateProduct,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
    # This function will add authentication to the route
    # it will return unauthorized in case of absence or invalid jwt token
):
    product = create_product(product, db, user)
    return product


@router.get("/")
def get_all(db: Session = Depends(get_db)):
    return get_all_products(db)


@router.put("/{id}")
def update_a_product(
    id: int,
    product: UpdateProduct,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):

    result = update_product(id, product, db, user)

    if isinstance(result, str):
        if (result == "not_found"):
            raise HTTPException(
                detail=f"product with id = {id} not found", status_code=status.HTTP_404_NOT_FOUND)
        elif (result == "unauthorized"):
            raise HTTPException(detail="Unauthorized",
                                status_code=status.HTTP_401_UNAUTHORIZED)

    return result


@router.delete("/{id}")
def delete_a_product(
    id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    result = delete_product(id, db, user)

    if (result == "not_found"):
        raise HTTPException(
            detail=f"product with id = {id} not found", status_code=status.HTTP_404_NOT_FOUND)
    elif (result == "unauthorized"):
        raise HTTPException(detail="Unauthorized",
                            status_code=status.HTTP_401_UNAUTHORIZED)

    return {"message": "product deleted successfully"}

================
File: api/route_user.py
================
from fastapi import APIRouter,Depends,status
from schemas.user import CreateUser,UserResponse
from sqlalchemy.orm import Session
from db.repository.user import create_user
from db.session import get_db

router = APIRouter()



@router.post("/",response_model=UserResponse,status_code=status.HTTP_201_CREATED)
def create_a_user(user:CreateUser,db:Session = Depends(get_db)):
    user = create_user(user,db)
    return user

================
File: core/config.py
================
import os
from dotenv import load_dotenv
load_dotenv()


class Settings:
    APP_NAME = os.getenv("APP_NAME")
    APP_VERSION = os.getenv("APP_VERSION")
    
    DB_USERNAME = os.getenv("DB_USERNAME")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_SERVER : str = os.getenv("DB_SERVER")
    DB_PORT : str = os.getenv("DB_PORT")
    DB_NAME : str = os.getenv("DB_NAME")
    DB_URL = f"postgresql://{DB_USERNAME}:{DB_PASSWORD}@{DB_SERVER}:{DB_PORT}/{DB_NAME}"
    
    SECRET_KEY: str = os.getenv("SECRET_KEY")
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30

    
    
settings = Settings()

#print(settings.APP_NAME)

================
File: core/hashing.py
================
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class Hasher:
    @staticmethod
    def verify_password(plain_password, hashed_password):
        return pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def get_password_hash(password):
        return pwd_context.hash(password)

================
File: core/jwt.py
================
from datetime import datetime
from datetime import timedelta
from typing import Optional

from core.config import settings
from jose import jwt


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM
    )
    return encoded_jwt

================
File: db/base_class.py
================
from typing import Any
from sqlalchemy.ext.declarative import as_declarative, declared_attr


@as_declarative()
class Base:
    id: Any
    __name__: str

    #to generate tablename from classname
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower()
    

# print(Base.metadata)

================
File: db/base.py
================
from db.base_class import Base
from db.models import product
from db.models import user
from db.models import category

================
File: db/models/category.py
================
from datetime import datetime
from sqlalchemy import Column, Integer, Text, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship

from db.base_class import Base


class Category(Base):
    id = Column(Integer, primary_key=True)
    name = Column(String,nullable=False)
    description = Column(Text)
    products = relationship("Product", back_populates="category")

================
File: db/models/product.py
================
from db.models.category import Category
from datetime import datetime
from sqlalchemy import Column, Integer, Text, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship

from db.base_class import Base


class Product(Base):
    id = Column(Integer, primary_key=True)
    name = Column(String,nullable=False)
    description = Column(Text)
    price = Column(Integer,nullable=False)
    stock_quantity = Column(Integer,nullable=False)
    # owner_id = Column(Integer, ForeignKey("user.id"))
    # owner = relationship("User", back_populates="products")
    category_id =  Column(Integer, ForeignKey("category.id"))
    category = relationship("Category", back_populates="products")

================
File: db/models/user.py
================
from datetime import datetime
from sqlalchemy import Column, Integer, Text, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship

from db.base_class import Base


class User(Base):
    id = Column(Integer, primary_key=True)
    username = Column(String,nullable=False,unique=True)
    password = Column(String,nullable=False)
    role = Column(String,nullable=False)
    # products = relationship("Product", back_populates="owner")

================
File: db/repository/category.py
================
from schemas.category import CreateCategory, UpdateCategory
from sqlalchemy.orm import Session 
from db.models.category import Category 
from db.models.user import User

def create_category(category:CreateCategory,db:Session,user:User):
    
    if user.role != "admin" and user.role != "manager":
        return "unauthorized"
    
    category = Category(**category.dict())
    
    db.add(category)
    db.commit()
    db.refresh(category)
    
    return category
    
def get_category_by_id(id:int,db:Session):
    category = db.query(Category).filter(Category.id == id).first()
    return category

def get_all_categories(db:Session):
    categories = db.query(Category).all()
    return categories

def update_categories(id:int,category:UpdateCategory,db:Session,user:User):
    stored_category = db.query(Category).filter(Category.id == id).first()
    
    if not(stored_category):
        return "not_found"
    
    if  user.role != "admin" and user.role != "manager":
        return "unauthorized"
    
    
    stored_category.name = category.name
    stored_category.description = category.description
   
    
    db.add(stored_category)
    db.commit()
    db.refresh(stored_category)
    return stored_category

def delete_category(id:int,db:Session,user:User):
    stored_category = db.query(Category).filter(Category.id == id)
    
    if not(stored_category.first()):
        return "not_found"
    
    if user.role != "admin" and user.role != "manager":
        return "unauthorized"
   
    stored_category.delete()
    db.commit()
    return "deleted"

================
File: db/repository/login.py
================
from db.models.user import User
from sqlalchemy.orm import Session


def get_user(username: str, db: Session):
    user = db.query(User).filter(User.username == username).first()
    return user

================
File: db/repository/product.py
================
from schemas.product import CreateProduct, UpdateProduct
from sqlalchemy.orm import Session, selectinload
from db.models.product import Product
from db.models.user import User


def create_product(product: CreateProduct, db: Session, user: User):

    if user.role != "admin" and user.role != "manager":
        return "unauthorized"

    product = Product(**product.dict())

    db.add(product)
    db.commit()
    db.refresh(product)

    return product


def get_product_by_id(id: int, db: Session):
    product = db.query(Product).filter(Product.id == id).options(
        selectinload(Product.category)).first()
    return product


def get_all_products(db: Session):
    products = db.query(Product).all()
    return products


def update_product(id: int, product: UpdateProduct, db: Session, user: User):
    stored_product = db.query(Product).filter(Product.id == id).options(
        selectinload(Product.category)).first()

    if not (stored_product):
        return "not_found"

    if user.role != "admin" and user.role != "manager":
        return "unauthorized"

    stored_product.name = product.name
    stored_product.description = product.description
    stored_product.stock_quantity = product.stock_quantity
    stored_product.price = product.price
    stored_product.category_id = product.category_id

    db.add(stored_product)
    db.commit()
    db.refresh(stored_product)

    return stored_product


def delete_product(id: int, db: Session, user: User):
    stored_product = db.query(Product).filter(Product.id == id)

    if not (stored_product.first()):
        return "not_found"

    if user.role != "admin" and user.role != "manager":
        return "unauthorized"

    stored_product.delete()
    db.commit()
    return "deleted"

================
File: db/repository/user.py
================
from schemas.user import CreateUser
from sqlalchemy.orm import Session
from db.models.user import User
from core.hashing import Hasher

def create_user(user:CreateUser,db:Session):
    print(user)
    user = User(
        username=user.username,
        password=Hasher.get_password_hash(user.password),
        role="user"
)
    
    db.add(user)
    db.commit()
    db.refresh(user)
    
    return user

================
File: db/session.py
================
from sqlalchemy import create_engine
from core.config import settings
from sqlalchemy.orm import sessionmaker
from typing import Generator

engine = create_engine(settings.DB_URL)

SessionLocal = sessionmaker(autocommit=False,autoflush=False,bind=engine)

def get_db() -> Generator:  
    try:
        db = SessionLocal()
        yield db
    finally:
        db.close()

================
File: main.py
================
from fastapi import FastAPI
from api.route_product import router as product_router
from api.route_user import router as user_router
from api.route_login import router as login_router
from api.route_category import router as category_router
from core.config import settings

app = FastAPI(title=settings.APP_NAME, version=settings.APP_VERSION)

app.include_router(product_router,prefix="/product")
app.include_router(user_router,prefix="/user")
app.include_router(login_router,prefix="/login")
app.include_router(category_router,prefix="/category")

@app.get('/')
def test():
    return {"message": "success"}

================
File: Pipfile
================
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
fastapi = {extras = ["standard"], version = "*"}
uvicorn = "*"
sqlalchemy = "*"
psycopg2 = "*"
python-dotenv = "*"
alembic = "*"
python-jose = "*"
passlib = {extras = ["bcrypt"], version = "*"}

[dev-packages]

[requires]
python_version = "3.10"

================
File: readme.md
================
### pipenv install "fastapi[standard]"

================
File: schemas/category.py
================
from pydantic import BaseModel
from typing import Optional

class CreateCategory(BaseModel):
    name:str
    description:Optional[str] = None


class UpdateCategory(CreateCategory):
    pass

================
File: schemas/product.py
================
from pydantic import BaseModel, validator
from typing import Optional
from db.repository.category import get_category_by_id
from db.session import get_db

class CreateProduct(BaseModel):
    name:str
    description:Optional[str] = None
    price:int
    stock_quantity:int
    category_id:Optional[int] = None
    
    @validator("category_id")
    def validate_category_id(cls,value):
        stored_category = get_category_by_id(value,get_db().__next__())
        if(not(stored_category)):
            raise ValueError(f"Category with id = {value} not found")
        return value

class UpdateProduct(CreateProduct):
    pass

================
File: schemas/token.py
================
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

================
File: schemas/user.py
================
from pydantic import BaseModel,validator
from typing import Optional
from db.repository.login import get_user
from db.session import get_db

class CreateUser(BaseModel):
    username:str 
    password:str
    
    @validator("username")
    def validate_username(cls,value):
        user = get_user(value,get_db().__next__())
        if(user):
            raise ValueError(f"username:{value} already exists")
        return value

class UserResponse(BaseModel):
    id:int 
    username:str 
    role:str
    
    class Config:  # tells pydantic to convert even non dict obj to json
        orm_mode = True
